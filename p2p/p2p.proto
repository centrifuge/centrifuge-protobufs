syntax = "proto3";

package p2p;

option go_package = "p2ppb";
option java_multiple_files = true;
option java_outer_classname = "P2pProto";
option java_package = "com.p2p";

import "coredocument/coredocument.proto";

message Header {
  uint32 network_identifier = 1;
  string node_version = 2;
  bytes sender_id = 3;
  // Body message type
  string type = 4;
}

message Envelope {
  Header header = 1;
  bytes body = 2;
}

message SignatureRequest {
  coredocument.CoreDocument document = 1;
}

message SignatureResponse {
  coredocument.Signature signature = 1;
}

message AnchorDocumentRequest {
  coredocument.CoreDocument document = 1;
}

message AnchorDocumentResponse {
  bool accepted = 1;
}

enum AccessType {
  ACCESS_TYPE_INVALID = 0;
  ACCESS_TYPE_REQUESTER_VERIFICATION = 1;
  ACCESS_TYPE_NFT_OWNER_VERIFICATION = 2;
  ACCESS_TYPE_ACCESS_TOKEN_VERIFICATION = 3;
}

message AccessToken {
  // The identifier is an internal 256bit word
  bytes identifier = 1;
  // The identity granting access to the document
  bytes granter = 7;
  // The identity being granted access to the document
  bytes grantee = 8;

  // Role identifier is the identifier on the read rule that this token should be mapped to
  bytes role_identifier = 9;

  // Original identifier of the document
  bytes document_identifier = 2;

  // TODO: if set, access will be limited to the specific version
  //  bytes read_version = 3;

  // TODO: if set, access will not be granted past a certain block height
  // int32 valid_until_block_height = 4;

  // TODO: Revocation: TBD in a later PR

  // If the boolean can_be_revoked is set to true, then this access token is revokable by setting the
  // revoked boolean value to true.
  //
  //  Making the token revokable comes at an extra cost as this requires submission of a proof that
  //  bool can_be_revoked = 5;
  //  bool revoked = 6;

  // Signature
  // Cryptographic signature that an access token is valid
  bytes signature = 10;
  // The public key of the signed message
  bytes key = 11;
}

message GetDocumentRequest {
  bytes document_identifier = 1;
  // Version of document? or should versioning be handled one layer down in AccessTypes?
  AccessType access_type = 2;
  bytes nft_registry_address = 3;
  bytes nft_token_id = 4;
}

message GetDocumentResponse {
  coredocument.CoreDocument document = 1;
}
