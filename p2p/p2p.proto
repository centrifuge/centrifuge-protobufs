syntax = "proto3";

package p2p;

option go_package = "p2ppb";
option java_multiple_files = true;
option java_outer_classname = "P2pProto";
option java_package = "com.p2p";

import "coredocument/coredocument.proto";

// P2PMessage wraps a single CoreDocument to be transferred to another node
message P2PMessage {
  uint32 network_identifier = 1;
  string cent_node_version = 2;
  bytes sender_centrifuge_id = 3;
  // Open questions in the P2PMessage
  // - should we include the document schema so the client can refuse it right away?
  // - how do you determine if the node is the right recipient for the current
  //   transaction (e.g. two different nodes with different keys are used for
  //   one centrifuge ID handling different data).
  coredocument.CoreDocument document = 5;
}

message P2PReply {
  string cent_node_version = 1;
  coredocument.CoreDocument document = 3;
}

message DocUpdateRequest {

  uint32 network_identifier = 1;
  string cent_node_version = 2;
  bytes sender_centrifuge_id = 3;
  coredocument.CoreDocument document = 5;
}
message DocUpdateResponse {
    string cent_node_version = 1;
    bytes signature = 2;
    bytes reciever_centrifuge_id = 3;
    coredocument.CoreDocument document = 4;
}
message AnchDocumentRequest {
    uint32 network_identifier = 1;
    string cent_node_version = 2;
    bytes sender_centrifuge_id = 3;
    coredocument.CoreDocument document = 4;
}
message AnchDocumentResponse {
    string cent_node_version = 1;
    bytes signature = 2;
    bytes reciever_centrifuge_id = 3;
    coredocument.CoreDocument document = 4;
}


// P2PService implementas all rpcs that can be called inside of the P2P network
service P2PService {
  // Post transmits a new version of the document to the recipient
  rpc Post(P2PMessage) returns (P2PReply);

  rpc RequestDocumentSignature(DocUpdateRequest) returns (DocUpdateResponse);

  //after all signatures are collected
  rpc SendAnchoredDocument(AnchDocumentRequest) returns (AnchDocumentResponse);
}
