// Code generated by protoc-gen-go. DO NOT EDIT.
// source: coredocument/coredocument.proto

package coredocumentpb

import (
	fmt "fmt"
	proto1 "github.com/centrifuge/precise-proofs/proofs/proto"
	proto "github.com/golang/protobuf/proto"
	any "github.com/golang/protobuf/ptypes/any"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Action defines the set of actions a collaborator can/have per document.
type Action int32

const (
	Action_ACTION_INVALID Action = 0
	// read_sign represents reading as well the sign the documents. We will pick this one when requesting the signatures.
	Action_ACTION_READ_SIGN Action = 1
	// read represents just reading the doc/fields
	Action_ACTION_READ Action = 2
)

var Action_name = map[int32]string{
	0: "ACTION_INVALID",
	1: "ACTION_READ_SIGN",
	2: "ACTION_READ",
}

var Action_value = map[string]int32{
	"ACTION_INVALID":   0,
	"ACTION_READ_SIGN": 1,
	"ACTION_READ":      2,
}

func (x Action) String() string {
	return proto.EnumName(Action_name, int32(x))
}

func (Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{0}
}

type FieldMatchType int32

const (
	FieldMatchType_FIELD_MATCH_TYPE_INVALID FieldMatchType = 0
	FieldMatchType_FIELD_MATCH_TYPE_PREFIX  FieldMatchType = 1
	FieldMatchType_FIELD_MATCH_TYPE_EXACT   FieldMatchType = 2
)

var FieldMatchType_name = map[int32]string{
	0: "FIELD_MATCH_TYPE_INVALID",
	1: "FIELD_MATCH_TYPE_PREFIX",
	2: "FIELD_MATCH_TYPE_EXACT",
}

var FieldMatchType_value = map[string]int32{
	"FIELD_MATCH_TYPE_INVALID": 0,
	"FIELD_MATCH_TYPE_PREFIX":  1,
	"FIELD_MATCH_TYPE_EXACT":   2,
}

func (x FieldMatchType) String() string {
	return proto.EnumName(FieldMatchType_name, int32(x))
}

func (FieldMatchType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{1}
}

type TransitionAction int32

const (
	TransitionAction_TRANSITION_ACTION_INVALID TransitionAction = 0
	TransitionAction_TRANSITION_ACTION_EDIT    TransitionAction = 1
)

var TransitionAction_name = map[int32]string{
	0: "TRANSITION_ACTION_INVALID",
	1: "TRANSITION_ACTION_EDIT",
}

var TransitionAction_value = map[string]int32{
	"TRANSITION_ACTION_INVALID": 0,
	"TRANSITION_ACTION_EDIT":    1,
}

func (x TransitionAction) String() string {
	return proto.EnumName(TransitionAction_name, int32(x))
}

func (TransitionAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{2}
}

// AttributeType defines the allowed attribute types.
type AttributeType int32

const (
	AttributeType_ATTRIBUTE_TYPE_INVALID   AttributeType = 0
	AttributeType_ATTRIBUTE_TYPE_INTEGER   AttributeType = 1
	AttributeType_ATTRIBUTE_TYPE_DECIMAL   AttributeType = 2
	AttributeType_ATTRIBUTE_TYPE_STRING    AttributeType = 3
	AttributeType_ATTRIBUTE_TYPE_BYTES     AttributeType = 4
	AttributeType_ATTRIBUTE_TYPE_TIMESTAMP AttributeType = 5
	AttributeType_ATTRIBUTE_TYPE_SIGNED    AttributeType = 6
	AttributeType_ATTRIBUTE_TYPE_MONETARY  AttributeType = 7
)

var AttributeType_name = map[int32]string{
	0: "ATTRIBUTE_TYPE_INVALID",
	1: "ATTRIBUTE_TYPE_INTEGER",
	2: "ATTRIBUTE_TYPE_DECIMAL",
	3: "ATTRIBUTE_TYPE_STRING",
	4: "ATTRIBUTE_TYPE_BYTES",
	5: "ATTRIBUTE_TYPE_TIMESTAMP",
	6: "ATTRIBUTE_TYPE_SIGNED",
	7: "ATTRIBUTE_TYPE_MONETARY",
}

var AttributeType_value = map[string]int32{
	"ATTRIBUTE_TYPE_INVALID":   0,
	"ATTRIBUTE_TYPE_INTEGER":   1,
	"ATTRIBUTE_TYPE_DECIMAL":   2,
	"ATTRIBUTE_TYPE_STRING":    3,
	"ATTRIBUTE_TYPE_BYTES":     4,
	"ATTRIBUTE_TYPE_TIMESTAMP": 5,
	"ATTRIBUTE_TYPE_SIGNED":    6,
	"ATTRIBUTE_TYPE_MONETARY":  7,
}

func (x AttributeType) String() string {
	return proto.EnumName(AttributeType_name, int32(x))
}

func (AttributeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{3}
}

// `CoreDocument` is a document that can be sent to different nodes and anchored
// on chain. It handles all the generic features native Centrifuge Documents support:
//
// * Merkle Roots for the document data
// * Signatures on document data
// * Access Control
type CoreDocument struct {
	// # Identifiers
	// CoreDocument has two kinds of identifiers, the `document_identifier` is assigned
	// once per document and stays the same for the lifetime of the document.
	// document_identifier is the first ID ever used to anchor the document on chain and
	// is used internally to store all future versions. The `previous_version`, `current_version`, and the
	// `next_version` refer only to a particular version.
	//
	// 32 byte value
	DocumentIdentifier []byte `protobuf:"bytes,9,opt,name=document_identifier,json=documentIdentifier,proto3" json:"document_identifier,omitempty"`
	// previous_version refers to the previous state of the document.
	// 32 byte value
	PreviousVersion []byte `protobuf:"bytes,16,opt,name=previous_version,json=previousVersion,proto3" json:"previous_version,omitempty"`
	// current_version is the version used to refer to the current state of the document.
	// 32 byte value
	CurrentVersion []byte `protobuf:"bytes,3,opt,name=current_version,json=currentVersion,proto3" json:"current_version,omitempty"`
	// current_preimage is the sha256 pre-image of the current_version. It prevents current state commitment id(anchor id) from getting exposed.
	// 32 byte value
	CurrentPreimage []byte `protobuf:"bytes,23,opt,name=current_preimage,json=currentPreimage,proto3" json:"current_preimage,omitempty"`
	// next_version is the version that is going to be used for the next version if any
	// party wants to update the state.
	NextVersion []byte `protobuf:"bytes,4,opt,name=next_version,json=nextVersion,proto3" json:"next_version,omitempty"`
	// next_preimage is the sha256 pre-image of the next_version. It prevents next state commitment id(anchor id) from getting exposed.
	NextPreimage []byte `protobuf:"bytes,22,opt,name=next_preimage,json=nextPreimage,proto3" json:"next_preimage,omitempty"`
	// Signatures of the signature_root by collaborators on the document.
	SignatureData *SignatureData `protobuf:"bytes,6,opt,name=signature_data,json=signatureData,proto3" json:"signature_data,omitempty"`
	// When a document is transmitted over the wire, the type specific fields (e.g. InvoiceData) are
	// embedded in the document using the google.protobuf.Any type.
	EmbeddedData *any.Any       `protobuf:"bytes,13,opt,name=embedded_data,json=embeddedData,proto3" json:"embedded_data,omitempty"`
	Salts        []*proto1.Salt `protobuf:"bytes,15,rep,name=salts,proto3" json:"salts,omitempty"`
	// list of roles
	Roles []*Role `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
	// read_rules define who may read a document and who should sign it
	ReadRules []*ReadRule `protobuf:"bytes,19,rep,name=read_rules,json=readRules,proto3" json:"read_rules,omitempty"`
	// transition rules define how a document may be manipulated
	TransitionRules []*TransitionRule `protobuf:"bytes,24,rep,name=transition_rules,json=transitionRules,proto3" json:"transition_rules,omitempty"`
	// nft list for uniqueness check
	Nfts []*NFT `protobuf:"bytes,20,rep,name=nfts,proto3" json:"nfts,omitempty"`
	// AccessTokens which have been added to this CoreDocument
	AccessTokens []*AccessToken `protobuf:"bytes,21,rep,name=access_tokens,json=accessTokens,proto3" json:"access_tokens,omitempty"`
	// author of the latest update
	Author []byte `protobuf:"bytes,25,opt,name=author,proto3" json:"author,omitempty"`
	// timestamp of the latest update
	Timestamp *timestamp.Timestamp `protobuf:"bytes,26,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// anchor repository address used to anchor this document
	AnchorRepositoryUsed []byte `protobuf:"bytes,27,opt,name=anchor_repository_used,json=anchorRepositoryUsed,proto3" json:"anchor_repository_used,omitempty"`
	// custom attributes(user defined fields) for this document
	Attributes           []*Attribute `protobuf:"bytes,28,rep,name=attributes,proto3" json:"attributes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CoreDocument) Reset()         { *m = CoreDocument{} }
func (m *CoreDocument) String() string { return proto.CompactTextString(m) }
func (*CoreDocument) ProtoMessage()    {}
func (*CoreDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{0}
}

func (m *CoreDocument) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CoreDocument.Unmarshal(m, b)
}
func (m *CoreDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CoreDocument.Marshal(b, m, deterministic)
}
func (m *CoreDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoreDocument.Merge(m, src)
}
func (m *CoreDocument) XXX_Size() int {
	return xxx_messageInfo_CoreDocument.Size(m)
}
func (m *CoreDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_CoreDocument.DiscardUnknown(m)
}

var xxx_messageInfo_CoreDocument proto.InternalMessageInfo

func (m *CoreDocument) GetDocumentIdentifier() []byte {
	if m != nil {
		return m.DocumentIdentifier
	}
	return nil
}

func (m *CoreDocument) GetPreviousVersion() []byte {
	if m != nil {
		return m.PreviousVersion
	}
	return nil
}

func (m *CoreDocument) GetCurrentVersion() []byte {
	if m != nil {
		return m.CurrentVersion
	}
	return nil
}

func (m *CoreDocument) GetCurrentPreimage() []byte {
	if m != nil {
		return m.CurrentPreimage
	}
	return nil
}

func (m *CoreDocument) GetNextVersion() []byte {
	if m != nil {
		return m.NextVersion
	}
	return nil
}

func (m *CoreDocument) GetNextPreimage() []byte {
	if m != nil {
		return m.NextPreimage
	}
	return nil
}

func (m *CoreDocument) GetSignatureData() *SignatureData {
	if m != nil {
		return m.SignatureData
	}
	return nil
}

func (m *CoreDocument) GetEmbeddedData() *any.Any {
	if m != nil {
		return m.EmbeddedData
	}
	return nil
}

func (m *CoreDocument) GetSalts() []*proto1.Salt {
	if m != nil {
		return m.Salts
	}
	return nil
}

func (m *CoreDocument) GetRoles() []*Role {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *CoreDocument) GetReadRules() []*ReadRule {
	if m != nil {
		return m.ReadRules
	}
	return nil
}

func (m *CoreDocument) GetTransitionRules() []*TransitionRule {
	if m != nil {
		return m.TransitionRules
	}
	return nil
}

func (m *CoreDocument) GetNfts() []*NFT {
	if m != nil {
		return m.Nfts
	}
	return nil
}

func (m *CoreDocument) GetAccessTokens() []*AccessToken {
	if m != nil {
		return m.AccessTokens
	}
	return nil
}

func (m *CoreDocument) GetAuthor() []byte {
	if m != nil {
		return m.Author
	}
	return nil
}

func (m *CoreDocument) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *CoreDocument) GetAnchorRepositoryUsed() []byte {
	if m != nil {
		return m.AnchorRepositoryUsed
	}
	return nil
}

func (m *CoreDocument) GetAttributes() []*Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type AccessToken struct {
	// The identifier is an internal 256bit word
	Identifier []byte `protobuf:"bytes,1,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// The identity granting access to the document
	Granter []byte `protobuf:"bytes,3,opt,name=granter,proto3" json:"granter,omitempty"`
	// The identity being granted access to the document
	Grantee []byte `protobuf:"bytes,4,opt,name=grantee,proto3" json:"grantee,omitempty"`
	// Role identifier is the identifier on the read rule that this token should be mapped to
	RoleIdentifier []byte `protobuf:"bytes,5,opt,name=role_identifier,json=roleIdentifier,proto3" json:"role_identifier,omitempty"`
	// Original identifier of the document
	DocumentIdentifier []byte `protobuf:"bytes,2,opt,name=document_identifier,json=documentIdentifier,proto3" json:"document_identifier,omitempty"`
	// Cryptographic signature that an access token is valid
	Signature []byte `protobuf:"bytes,6,opt,name=signature,proto3" json:"signature,omitempty"`
	// The public key of the signed message
	Key []byte `protobuf:"bytes,7,opt,name=key,proto3" json:"key,omitempty"`
	// The document version refers to a version of the document this token is embedded in. Its timestamp
	// will be used to verify the validity of the signature of the access token.
	DocumentVersion      []byte   `protobuf:"bytes,8,opt,name=document_version,json=documentVersion,proto3" json:"document_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessToken) Reset()         { *m = AccessToken{} }
func (m *AccessToken) String() string { return proto.CompactTextString(m) }
func (*AccessToken) ProtoMessage()    {}
func (*AccessToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{1}
}

func (m *AccessToken) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccessToken.Unmarshal(m, b)
}
func (m *AccessToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccessToken.Marshal(b, m, deterministic)
}
func (m *AccessToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessToken.Merge(m, src)
}
func (m *AccessToken) XXX_Size() int {
	return xxx_messageInfo_AccessToken.Size(m)
}
func (m *AccessToken) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessToken.DiscardUnknown(m)
}

var xxx_messageInfo_AccessToken proto.InternalMessageInfo

func (m *AccessToken) GetIdentifier() []byte {
	if m != nil {
		return m.Identifier
	}
	return nil
}

func (m *AccessToken) GetGranter() []byte {
	if m != nil {
		return m.Granter
	}
	return nil
}

func (m *AccessToken) GetGrantee() []byte {
	if m != nil {
		return m.Grantee
	}
	return nil
}

func (m *AccessToken) GetRoleIdentifier() []byte {
	if m != nil {
		return m.RoleIdentifier
	}
	return nil
}

func (m *AccessToken) GetDocumentIdentifier() []byte {
	if m != nil {
		return m.DocumentIdentifier
	}
	return nil
}

func (m *AccessToken) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *AccessToken) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *AccessToken) GetDocumentVersion() []byte {
	if m != nil {
		return m.DocumentVersion
	}
	return nil
}

// SignatureData contains the list of signatures identified by the signature_id
type SignatureData struct {
	Signatures           []*Signature `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SignatureData) Reset()         { *m = SignatureData{} }
func (m *SignatureData) String() string { return proto.CompactTextString(m) }
func (*SignatureData) ProtoMessage()    {}
func (*SignatureData) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{2}
}

func (m *SignatureData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignatureData.Unmarshal(m, b)
}
func (m *SignatureData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignatureData.Marshal(b, m, deterministic)
}
func (m *SignatureData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureData.Merge(m, src)
}
func (m *SignatureData) XXX_Size() int {
	return xxx_messageInfo_SignatureData.Size(m)
}
func (m *SignatureData) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureData.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureData proto.InternalMessageInfo

func (m *SignatureData) GetSignatures() []*Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// Signature contains the entity ID, public key used and signature)
type Signature struct {
	// `signature_id` is a composed key signer_id+public_key used
	SignatureId []byte `protobuf:"bytes,1,opt,name=signature_id,json=signatureId,proto3" json:"signature_id,omitempty"`
	// `signer_id` is the CentrifugeID of the identity signing the document.
	SignerId []byte `protobuf:"bytes,2,opt,name=signer_id,json=signerId,proto3" json:"signer_id,omitempty"`
	// `public_key` is the public key of the `signer` used for signing the `CoreDocument`
	PublicKey []byte `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// `signature` is the actual signature of the CoreDocument
	Signature            []byte   `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{3}
}

func (m *Signature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Signature.Unmarshal(m, b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return xxx_messageInfo_Signature.Size(m)
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetSignatureId() []byte {
	if m != nil {
		return m.SignatureId
	}
	return nil
}

func (m *Signature) GetSignerId() []byte {
	if m != nil {
		return m.SignerId
	}
	return nil
}

func (m *Signature) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *Signature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Roles holds a list of collaborators, NFTs, and/or access tokens.
type Role struct {
	// role key which is used to identify the group internally and map the role to rules
	RoleKey []byte `protobuf:"bytes,1,opt,name=role_key,json=roleKey,proto3" json:"role_key,omitempty"`
	// collaborators holds the list of document collaborators
	Collaborators [][]byte `protobuf:"bytes,3,rep,name=collaborators,proto3" json:"collaborators,omitempty"`
	// nfts is a list of registry address/tokenID pairs.
	// For easier verification in merkle proofs, the values are simply concatenated with the first 22 bytes being the NFT registry and the remaining 32 bytes the tokenID.
	Nfts                 [][]byte `protobuf:"bytes,4,rep,name=nfts,proto3" json:"nfts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Role) Reset()         { *m = Role{} }
func (m *Role) String() string { return proto.CompactTextString(m) }
func (*Role) ProtoMessage()    {}
func (*Role) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{4}
}

func (m *Role) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Role.Unmarshal(m, b)
}
func (m *Role) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Role.Marshal(b, m, deterministic)
}
func (m *Role) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Role.Merge(m, src)
}
func (m *Role) XXX_Size() int {
	return xxx_messageInfo_Role.Size(m)
}
func (m *Role) XXX_DiscardUnknown() {
	xxx_messageInfo_Role.DiscardUnknown(m)
}

var xxx_messageInfo_Role proto.InternalMessageInfo

func (m *Role) GetRoleKey() []byte {
	if m != nil {
		return m.RoleKey
	}
	return nil
}

func (m *Role) GetCollaborators() [][]byte {
	if m != nil {
		return m.Collaborators
	}
	return nil
}

func (m *Role) GetNfts() [][]byte {
	if m != nil {
		return m.Nfts
	}
	return nil
}

type ReadRule struct {
	Roles                [][]byte `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"`
	Action               Action   `protobuf:"varint,4,opt,name=action,proto3,enum=coredocument.Action" json:"action,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadRule) Reset()         { *m = ReadRule{} }
func (m *ReadRule) String() string { return proto.CompactTextString(m) }
func (*ReadRule) ProtoMessage()    {}
func (*ReadRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{5}
}

func (m *ReadRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadRule.Unmarshal(m, b)
}
func (m *ReadRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadRule.Marshal(b, m, deterministic)
}
func (m *ReadRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadRule.Merge(m, src)
}
func (m *ReadRule) XXX_Size() int {
	return xxx_messageInfo_ReadRule.Size(m)
}
func (m *ReadRule) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadRule.DiscardUnknown(m)
}

var xxx_messageInfo_ReadRule proto.InternalMessageInfo

func (m *ReadRule) GetRoles() [][]byte {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *ReadRule) GetAction() Action {
	if m != nil {
		return m.Action
	}
	return Action_ACTION_INVALID
}

type TransitionRule struct {
	// rule key, to help track of the rule
	RuleKey []byte `protobuf:"bytes,1,opt,name=rule_key,json=ruleKey,proto3" json:"rule_key,omitempty"`
	// Indicates which roles can make changes or read the fields specified:
	// this list holds role keys correlated to those in the 'roles' field of the CoreDocument
	Roles [][]byte `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"`
	// prefix or exact
	MatchType FieldMatchType `protobuf:"varint,3,opt,name=match_type,json=matchType,proto3,enum=coredocument.FieldMatchType" json:"match_type,omitempty"`
	// compact property of the field
	Field []byte `protobuf:"bytes,4,opt,name=field,proto3" json:"field,omitempty"`
	// what kind of action this rule allows
	Action               TransitionAction `protobuf:"varint,5,opt,name=action,proto3,enum=coredocument.TransitionAction" json:"action,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TransitionRule) Reset()         { *m = TransitionRule{} }
func (m *TransitionRule) String() string { return proto.CompactTextString(m) }
func (*TransitionRule) ProtoMessage()    {}
func (*TransitionRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{6}
}

func (m *TransitionRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransitionRule.Unmarshal(m, b)
}
func (m *TransitionRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransitionRule.Marshal(b, m, deterministic)
}
func (m *TransitionRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransitionRule.Merge(m, src)
}
func (m *TransitionRule) XXX_Size() int {
	return xxx_messageInfo_TransitionRule.Size(m)
}
func (m *TransitionRule) XXX_DiscardUnknown() {
	xxx_messageInfo_TransitionRule.DiscardUnknown(m)
}

var xxx_messageInfo_TransitionRule proto.InternalMessageInfo

func (m *TransitionRule) GetRuleKey() []byte {
	if m != nil {
		return m.RuleKey
	}
	return nil
}

func (m *TransitionRule) GetRoles() [][]byte {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *TransitionRule) GetMatchType() FieldMatchType {
	if m != nil {
		return m.MatchType
	}
	return FieldMatchType_FIELD_MATCH_TYPE_INVALID
}

func (m *TransitionRule) GetField() []byte {
	if m != nil {
		return m.Field
	}
	return nil
}

func (m *TransitionRule) GetAction() TransitionAction {
	if m != nil {
		return m.Action
	}
	return TransitionAction_TRANSITION_ACTION_INVALID
}

type NFT struct {
	RegistryId           []byte   `protobuf:"bytes,1,opt,name=registry_id,json=registryId,proto3" json:"registry_id,omitempty"`
	TokenId              []byte   `protobuf:"bytes,2,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NFT) Reset()         { *m = NFT{} }
func (m *NFT) String() string { return proto.CompactTextString(m) }
func (*NFT) ProtoMessage()    {}
func (*NFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{7}
}

func (m *NFT) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NFT.Unmarshal(m, b)
}
func (m *NFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NFT.Marshal(b, m, deterministic)
}
func (m *NFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NFT.Merge(m, src)
}
func (m *NFT) XXX_Size() int {
	return xxx_messageInfo_NFT.Size(m)
}
func (m *NFT) XXX_DiscardUnknown() {
	xxx_messageInfo_NFT.DiscardUnknown(m)
}

var xxx_messageInfo_NFT proto.InternalMessageInfo

func (m *NFT) GetRegistryId() []byte {
	if m != nil {
		return m.RegistryId
	}
	return nil
}

func (m *NFT) GetTokenId() []byte {
	if m != nil {
		return m.TokenId
	}
	return nil
}

// Attribute represents a custom attribute
type Attribute struct {
	Key      []byte        `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	KeyLabel []byte        `protobuf:"bytes,2,opt,name=key_label,json=keyLabel,proto3" json:"key_label,omitempty"`
	Type     AttributeType `protobuf:"varint,3,opt,name=type,proto3,enum=coredocument.AttributeType" json:"type,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*Attribute_StrVal
	//	*Attribute_ByteVal
	//	*Attribute_TimeVal
	//	*Attribute_SignedVal
	//	*Attribute_MonetaryVal
	Value                isAttribute_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Attribute) Reset()         { *m = Attribute{} }
func (m *Attribute) String() string { return proto.CompactTextString(m) }
func (*Attribute) ProtoMessage()    {}
func (*Attribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{8}
}

func (m *Attribute) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Attribute.Unmarshal(m, b)
}
func (m *Attribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Attribute.Marshal(b, m, deterministic)
}
func (m *Attribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Attribute.Merge(m, src)
}
func (m *Attribute) XXX_Size() int {
	return xxx_messageInfo_Attribute.Size(m)
}
func (m *Attribute) XXX_DiscardUnknown() {
	xxx_messageInfo_Attribute.DiscardUnknown(m)
}

var xxx_messageInfo_Attribute proto.InternalMessageInfo

func (m *Attribute) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Attribute) GetKeyLabel() []byte {
	if m != nil {
		return m.KeyLabel
	}
	return nil
}

func (m *Attribute) GetType() AttributeType {
	if m != nil {
		return m.Type
	}
	return AttributeType_ATTRIBUTE_TYPE_INVALID
}

type isAttribute_Value interface {
	isAttribute_Value()
}

type Attribute_StrVal struct {
	StrVal string `protobuf:"bytes,4,opt,name=str_val,json=strVal,proto3,oneof"`
}

type Attribute_ByteVal struct {
	ByteVal []byte `protobuf:"bytes,5,opt,name=byte_val,json=byteVal,proto3,oneof"`
}

type Attribute_TimeVal struct {
	TimeVal *timestamp.Timestamp `protobuf:"bytes,6,opt,name=time_val,json=timeVal,proto3,oneof"`
}

type Attribute_SignedVal struct {
	SignedVal *Signed `protobuf:"bytes,7,opt,name=signed_val,json=signedVal,proto3,oneof"`
}

type Attribute_MonetaryVal struct {
	MonetaryVal *Monetary `protobuf:"bytes,8,opt,name=monetary_val,json=monetaryVal,proto3,oneof"`
}

func (*Attribute_StrVal) isAttribute_Value() {}

func (*Attribute_ByteVal) isAttribute_Value() {}

func (*Attribute_TimeVal) isAttribute_Value() {}

func (*Attribute_SignedVal) isAttribute_Value() {}

func (*Attribute_MonetaryVal) isAttribute_Value() {}

func (m *Attribute) GetValue() isAttribute_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Attribute) GetStrVal() string {
	if x, ok := m.GetValue().(*Attribute_StrVal); ok {
		return x.StrVal
	}
	return ""
}

func (m *Attribute) GetByteVal() []byte {
	if x, ok := m.GetValue().(*Attribute_ByteVal); ok {
		return x.ByteVal
	}
	return nil
}

func (m *Attribute) GetTimeVal() *timestamp.Timestamp {
	if x, ok := m.GetValue().(*Attribute_TimeVal); ok {
		return x.TimeVal
	}
	return nil
}

func (m *Attribute) GetSignedVal() *Signed {
	if x, ok := m.GetValue().(*Attribute_SignedVal); ok {
		return x.SignedVal
	}
	return nil
}

func (m *Attribute) GetMonetaryVal() *Monetary {
	if x, ok := m.GetValue().(*Attribute_MonetaryVal); ok {
		return x.MonetaryVal
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Attribute) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Attribute_StrVal)(nil),
		(*Attribute_ByteVal)(nil),
		(*Attribute_TimeVal)(nil),
		(*Attribute_SignedVal)(nil),
		(*Attribute_MonetaryVal)(nil),
	}
}

// Signed holds the custom attribute signature type
type Signed struct {
	DocVersion []byte `protobuf:"bytes,1,opt,name=doc_version,json=docVersion,proto3" json:"doc_version,omitempty"`
	Value      []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Identity   []byte `protobuf:"bytes,3,opt,name=identity,proto3" json:"identity,omitempty"`
	// signature = sign(identity + doc_id(taken from the document.document_identifier) + doc_version + value)
	Signature            []byte   `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	PublicKey            []byte   `protobuf:"bytes,5,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Signed) Reset()         { *m = Signed{} }
func (m *Signed) String() string { return proto.CompactTextString(m) }
func (*Signed) ProtoMessage()    {}
func (*Signed) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{9}
}

func (m *Signed) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Signed.Unmarshal(m, b)
}
func (m *Signed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Signed.Marshal(b, m, deterministic)
}
func (m *Signed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signed.Merge(m, src)
}
func (m *Signed) XXX_Size() int {
	return xxx_messageInfo_Signed.Size(m)
}
func (m *Signed) XXX_DiscardUnknown() {
	xxx_messageInfo_Signed.DiscardUnknown(m)
}

var xxx_messageInfo_Signed proto.InternalMessageInfo

func (m *Signed) GetDocVersion() []byte {
	if m != nil {
		return m.DocVersion
	}
	return nil
}

func (m *Signed) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Signed) GetIdentity() []byte {
	if m != nil {
		return m.Identity
	}
	return nil
}

func (m *Signed) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Signed) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// Monetary holds decimal value, id and chain context
type Monetary struct {
	Value                []byte   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Chain                []byte   `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain,omitempty"`
	Id                   []byte   `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Monetary) Reset()         { *m = Monetary{} }
func (m *Monetary) String() string { return proto.CompactTextString(m) }
func (*Monetary) ProtoMessage()    {}
func (*Monetary) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{10}
}

func (m *Monetary) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Monetary.Unmarshal(m, b)
}
func (m *Monetary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Monetary.Marshal(b, m, deterministic)
}
func (m *Monetary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Monetary.Merge(m, src)
}
func (m *Monetary) XXX_Size() int {
	return xxx_messageInfo_Monetary.Size(m)
}
func (m *Monetary) XXX_DiscardUnknown() {
	xxx_messageInfo_Monetary.DiscardUnknown(m)
}

var xxx_messageInfo_Monetary proto.InternalMessageInfo

func (m *Monetary) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Monetary) GetChain() []byte {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *Monetary) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func init() {
	proto.RegisterEnum("coredocument.Action", Action_name, Action_value)
	proto.RegisterEnum("coredocument.FieldMatchType", FieldMatchType_name, FieldMatchType_value)
	proto.RegisterEnum("coredocument.TransitionAction", TransitionAction_name, TransitionAction_value)
	proto.RegisterEnum("coredocument.AttributeType", AttributeType_name, AttributeType_value)
	proto.RegisterType((*CoreDocument)(nil), "coredocument.CoreDocument")
	proto.RegisterType((*AccessToken)(nil), "coredocument.AccessToken")
	proto.RegisterType((*SignatureData)(nil), "coredocument.SignatureData")
	proto.RegisterType((*Signature)(nil), "coredocument.Signature")
	proto.RegisterType((*Role)(nil), "coredocument.Role")
	proto.RegisterType((*ReadRule)(nil), "coredocument.ReadRule")
	proto.RegisterType((*TransitionRule)(nil), "coredocument.TransitionRule")
	proto.RegisterType((*NFT)(nil), "coredocument.NFT")
	proto.RegisterType((*Attribute)(nil), "coredocument.Attribute")
	proto.RegisterType((*Signed)(nil), "coredocument.Signed")
	proto.RegisterType((*Monetary)(nil), "coredocument.Monetary")
}

func init() { proto.RegisterFile("coredocument/coredocument.proto", fileDescriptor_eb191193ab8e2cd4) }

var fileDescriptor_eb191193ab8e2cd4 = []byte{
	// 1424 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x56, 0xcb, 0x72, 0xdb, 0xc6,
	0x12, 0x15, 0x28, 0xf1, 0xd5, 0x7c, 0x08, 0x1e, 0xd3, 0x12, 0xf4, 0xb0, 0xad, 0xcb, 0x7b, 0xeb,
	0x5a, 0x56, 0x25, 0x52, 0x95, 0x63, 0xc7, 0xa9, 0x4a, 0x16, 0x21, 0x45, 0x4a, 0x42, 0x45, 0xa4,
	0x55, 0x10, 0xac, 0xb2, 0x93, 0x05, 0x32, 0x04, 0x46, 0x14, 0x4a, 0x20, 0xc0, 0x1a, 0x0c, 0x55,
	0xe1, 0x1f, 0xe4, 0x0b, 0x52, 0x59, 0xe6, 0x13, 0xb2, 0xce, 0x2a, 0xde, 0xe7, 0x07, 0xb2, 0xcb,
	0x17, 0x64, 0xe7, 0x7d, 0x6a, 0x06, 0x18, 0x10, 0x80, 0x2c, 0x67, 0x25, 0x74, 0xf7, 0xe9, 0x9e,
	0x9e, 0xee, 0x39, 0x87, 0x82, 0xc7, 0x76, 0x40, 0x89, 0x13, 0xd8, 0xb3, 0x09, 0xf1, 0xd9, 0x41,
	0xda, 0xd8, 0x9f, 0xd2, 0x80, 0x05, 0xa8, 0x9e, 0xf6, 0x6d, 0x6e, 0x8c, 0x83, 0x60, 0xec, 0x91,
	0x03, 0x11, 0x1b, 0xcd, 0x2e, 0x0f, 0xb0, 0x3f, 0x8f, 0x80, 0x9b, 0x8f, 0xf3, 0x21, 0xe6, 0x4e,
	0x48, 0xc8, 0xf0, 0x64, 0x1a, 0x03, 0x9e, 0x4c, 0x29, 0xb1, 0xdd, 0x90, 0x7c, 0x3a, 0xa5, 0x41,
	0x70, 0x19, 0x1e, 0x2c, 0xfe, 0xb0, 0x20, 0x32, 0x62, 0xe0, 0xff, 0x3f, 0x06, 0x0c, 0xb1, 0x17,
	0xb7, 0xd6, 0xfe, 0xb3, 0x0c, 0xf5, 0xc3, 0x80, 0x92, 0x5e, 0xdc, 0x1d, 0x3a, 0x80, 0xfb, 0xb2,
	0x53, 0xcb, 0x75, 0x88, 0xcf, 0xdc, 0x4b, 0x97, 0x50, 0xad, 0xba, 0xa3, 0xec, 0xd6, 0x0d, 0x24,
	0x43, 0x7a, 0x12, 0x41, 0x4f, 0x41, 0x9d, 0x52, 0x72, 0xe3, 0x06, 0xb3, 0xd0, 0xba, 0x21, 0x34,
	0x74, 0x03, 0x5f, 0x53, 0x05, 0x7a, 0x55, 0xfa, 0x2f, 0x22, 0x37, 0x7a, 0x02, 0xab, 0xf6, 0x8c,
	0x52, 0x5e, 0x5a, 0x22, 0x97, 0x05, 0xb2, 0x19, 0xbb, 0x25, 0xf0, 0x29, 0xa8, 0x12, 0x38, 0xa5,
	0xc4, 0x9d, 0xe0, 0x31, 0xd1, 0xd6, 0xa3, 0x9a, 0xb1, 0xff, 0x2c, 0x76, 0xa3, 0xff, 0x40, 0xdd,
	0x27, 0x3f, 0x2c, 0x0a, 0xae, 0x08, 0x58, 0x8d, 0xfb, 0x64, 0xb5, 0xff, 0x42, 0x43, 0x40, 0x92,
	0x52, 0x6b, 0x02, 0x23, 0xf2, 0x92, 0x3a, 0x3a, 0x34, 0x43, 0x77, 0xec, 0x63, 0x36, 0xa3, 0xc4,
	0x72, 0x30, 0xc3, 0x5a, 0x69, 0x47, 0xd9, 0xad, 0x3d, 0xdb, 0xda, 0xcf, 0x2c, 0xf4, 0x5c, 0x62,
	0x7a, 0x98, 0xe1, 0x6e, 0xf1, 0x97, 0x77, 0xef, 0x41, 0x31, 0x1a, 0x61, 0xda, 0x8b, 0xbe, 0x86,
	0x06, 0x99, 0x8c, 0x88, 0xe3, 0x10, 0x27, 0xaa, 0xd4, 0x10, 0x95, 0x5a, 0xfb, 0xd1, 0x76, 0xf7,
	0xe5, 0x76, 0xf7, 0x3b, 0xfe, 0x5c, 0x96, 0xa8, 0xcb, 0x0c, 0x51, 0xa1, 0x0d, 0x45, 0xbe, 0xa3,
	0x50, 0x5b, 0xdd, 0x59, 0xde, 0xad, 0x3d, 0xab, 0xef, 0x47, 0xeb, 0xdb, 0x3f, 0xc7, 0x1e, 0x33,
	0xa2, 0x10, 0xfa, 0x0a, 0x8a, 0x34, 0xf0, 0x48, 0xa8, 0x29, 0x02, 0x83, 0xb2, 0x7d, 0x1a, 0x81,
	0x47, 0xba, 0xe8, 0xd7, 0x77, 0xef, 0x61, 0xe7, 0xb7, 0x77, 0xef, 0xa1, 0xc2, 0xa1, 0xd6, 0x35,
	0x99, 0x1b, 0x51, 0x12, 0x7a, 0x01, 0x40, 0x09, 0x76, 0x2c, 0x3a, 0xe3, 0x25, 0xee, 0x8b, 0x12,
	0x6b, 0xb9, 0x12, 0x04, 0x3b, 0xc6, 0xcc, 0x23, 0x46, 0x95, 0xc6, 0x5f, 0x21, 0x3a, 0x06, 0x95,
	0x51, 0xec, 0x87, 0x2e, 0x73, 0x03, 0x3f, 0x4e, 0xd6, 0x44, 0xf2, 0x76, 0x36, 0xd9, 0x4c, 0x50,
	0xa2, 0xc4, 0x2a, 0xcb, 0xd8, 0xbc, 0xfb, 0x15, 0xff, 0x92, 0x85, 0x5a, 0x4b, 0x24, 0xdf, 0xcb,
	0x26, 0x0f, 0x8f, 0xcc, 0xee, 0x83, 0xa4, 0xf7, 0x1a, 0x25, 0x63, 0x37, 0x64, 0x74, 0x6e, 0xb9,
	0x8e, 0x21, 0xb2, 0x90, 0x09, 0x0d, 0x6c, 0xdb, 0x24, 0x0c, 0x2d, 0x16, 0x5c, 0x13, 0x3f, 0xd4,
	0x1e, 0x88, 0x32, 0x1b, 0xd9, 0x32, 0x1d, 0x01, 0x31, 0x39, 0xa2, 0xdb, 0x4a, 0xca, 0xc1, 0xe2,
	0x55, 0x1b, 0x75, 0xbc, 0x80, 0x84, 0x68, 0x0d, 0x4a, 0x78, 0xc6, 0xae, 0x02, 0xaa, 0x6d, 0x88,
	0x07, 0x12, 0x5b, 0xe8, 0x0b, 0xa8, 0x26, 0x3c, 0xd4, 0x36, 0xc5, 0x2e, 0x37, 0x6f, 0xed, 0xd2,
	0x94, 0x08, 0x63, 0x01, 0x46, 0xcf, 0x61, 0x0d, 0xfb, 0xf6, 0x55, 0x40, 0x2d, 0x4a, 0xa6, 0x41,
	0xe8, 0xb2, 0x80, 0xce, 0xad, 0x59, 0x48, 0x1c, 0x6d, 0x4b, 0x9c, 0xd0, 0x8a, 0xa2, 0x46, 0x12,
	0x7c, 0x1d, 0x12, 0x07, 0x1d, 0x01, 0x60, 0xc6, 0xa8, 0x3b, 0x9a, 0x31, 0x12, 0x6a, 0xdb, 0xe2,
	0x6a, 0xeb, 0xb9, 0xab, 0xc9, 0x78, 0xb7, 0x91, 0x5c, 0x6c, 0x99, 0xaf, 0x37, 0x95, 0xd9, 0xfe,
	0xa9, 0x00, 0xb5, 0xd4, 0x0c, 0xd0, 0xa3, 0xf4, 0xdd, 0x35, 0x45, 0x74, 0x90, 0xf2, 0x20, 0x0d,
	0xca, 0x63, 0x8a, 0x7d, 0x46, 0x68, 0x4c, 0x4b, 0x69, 0x2e, 0x22, 0x24, 0xe6, 0x97, 0x34, 0x39,
	0xa5, 0xc5, 0xd3, 0x4a, 0x15, 0x2e, 0x46, 0x94, 0xe6, 0xee, 0x94, 0x4c, 0xdc, 0xa1, 0x2b, 0x85,
	0x3b, 0x75, 0x65, 0x1b, 0xaa, 0x09, 0xad, 0x04, 0x17, 0xeb, 0xc6, 0xc2, 0x81, 0x54, 0x71, 0x5d,
	0xad, 0x2c, 0xfc, 0xfc, 0x93, 0x6b, 0x46, 0x72, 0x80, 0x14, 0x83, 0x4a, 0xa4, 0x19, 0xd2, 0x1f,
	0x0b, 0x42, 0xfb, 0x7b, 0x68, 0x64, 0x78, 0x8c, 0x5e, 0x01, 0x24, 0xa5, 0x25, 0xa1, 0xd6, 0xef,
	0x20, 0x7e, 0x77, 0x8d, 0x4f, 0xfc, 0x39, 0x9f, 0x78, 0x7d, 0xa1, 0x18, 0xae, 0x63, 0xa4, 0x4a,
	0xb4, 0x7f, 0x54, 0xa0, 0x9a, 0x64, 0x70, 0x8d, 0x4a, 0x23, 0xe3, 0xd1, 0xd7, 0x12, 0x9f, 0xee,
	0xa0, 0xad, 0xe8, 0xb6, 0x84, 0xf2, 0x78, 0x34, 0x94, 0x4a, 0xe4, 0xd0, 0x1d, 0xf4, 0x10, 0x60,
	0x3a, 0x1b, 0x79, 0xae, 0xcd, 0x19, 0x1c, 0xef, 0xa6, 0x1a, 0x79, 0xbe, 0x21, 0xf3, 0xec, 0xa4,
	0x56, 0x72, 0x93, 0x6a, 0x7f, 0x07, 0x2b, 0x5c, 0x0c, 0xd0, 0xc6, 0x42, 0x04, 0xe2, 0x06, 0xca,
	0xdc, 0xe6, 0x05, 0xfe, 0x07, 0x0d, 0x3b, 0xf0, 0x3c, 0x3c, 0x0a, 0x28, 0x66, 0x01, 0x0d, 0xb5,
	0xe5, 0x9d, 0xe5, 0xdd, 0xba, 0x91, 0x75, 0x22, 0x14, 0x53, 0x76, 0x45, 0x04, 0xc5, 0x77, 0x7b,
	0x08, 0x15, 0x29, 0x13, 0xa8, 0x25, 0x05, 0xa9, 0x20, 0x00, 0xb1, 0xd0, 0x7c, 0x02, 0x25, 0x6c,
	0x33, 0xa9, 0xcc, 0xcd, 0x67, 0xad, 0x3c, 0x47, 0x85, 0x26, 0xc4, 0x98, 0xf6, 0x1f, 0x0a, 0x34,
	0xb3, 0xd2, 0x21, 0xfa, 0x9e, 0xe5, 0xfa, 0x9e, 0x45, 0x7d, 0x7f, 0xf8, 0xc4, 0x2f, 0x01, 0x26,
	0x98, 0xd9, 0x57, 0x16, 0x9b, 0x4f, 0x89, 0x98, 0x56, 0x33, 0xaf, 0x4e, 0x47, 0x2e, 0xf1, 0x9c,
	0x01, 0x07, 0x99, 0xf3, 0x29, 0x31, 0xaa, 0x13, 0xf9, 0xc9, 0x4b, 0x5e, 0xf2, 0x60, 0x3c, 0xc7,
	0xc8, 0x40, 0x9f, 0x27, 0x97, 0x28, 0x8a, 0x72, 0x8f, 0xee, 0x12, 0xbb, 0xdc, 0x75, 0x3a, 0xb0,
	0x3c, 0x3c, 0x32, 0xd1, 0xe3, 0x8c, 0x86, 0x49, 0xe6, 0x49, 0x97, 0xee, 0xf0, 0x3b, 0x0a, 0x21,
	0x5b, 0x2c, 0xbf, 0x2c, 0x6c, 0xdd, 0x69, 0xff, 0x55, 0x80, 0x6a, 0xc2, 0x76, 0xf9, 0xec, 0x95,
	0xc5, 0xb3, 0xdf, 0x82, 0xea, 0x35, 0x99, 0x5b, 0x1e, 0x1e, 0x11, 0x4f, 0x3e, 0x9c, 0x6b, 0x32,
	0x3f, 0xe5, 0x36, 0x3a, 0x80, 0x95, 0xd4, 0x10, 0xb6, 0xee, 0xd0, 0x10, 0x31, 0x03, 0x01, 0x44,
	0x1b, 0x50, 0x0e, 0x19, 0xb5, 0x6e, 0xb0, 0x27, 0x06, 0x50, 0x3d, 0x59, 0x32, 0x4a, 0x21, 0xa3,
	0x17, 0xd8, 0x43, 0x5b, 0x50, 0x19, 0xcd, 0x19, 0x11, 0x31, 0x41, 0xf1, 0x93, 0x25, 0xa3, 0xcc,
	0x3d, 0x3c, 0xf8, 0x12, 0x2a, 0x5c, 0xf5, 0x44, 0xb0, 0xf4, 0x6f, 0x0a, 0xc9, 0x13, 0x39, 0x9a,
	0x27, 0xbe, 0x88, 0x98, 0x47, 0x1c, 0x91, 0x5a, 0x8e, 0x7f, 0x28, 0x6f, 0x31, 0x8f, 0x38, 0x27,
	0x4b, 0xd1, 0xa3, 0x26, 0x0e, 0x4f, 0xeb, 0x42, 0x7d, 0x12, 0xf8, 0x84, 0x61, 0x3a, 0x17, 0x89,
	0x15, 0x91, 0x98, 0xfb, 0x01, 0x1b, 0xc4, 0x88, 0x6e, 0xf1, 0x77, 0xfe, 0x1b, 0x7b, 0xb2, 0x64,
	0xd4, 0x64, 0xd2, 0x05, 0xf6, 0xba, 0x65, 0x28, 0xde, 0x60, 0x6f, 0x46, 0xda, 0x3f, 0x2b, 0x50,
	0x8a, 0x0e, 0xe1, 0x9b, 0x72, 0x02, 0x3b, 0xd1, 0x8f, 0x78, 0x53, 0x4e, 0x60, 0xcb, 0xff, 0x25,
	0x5a, 0x71, 0x52, 0x3c, 0xea, 0xc8, 0x40, 0x9b, 0x50, 0x89, 0x34, 0x8d, 0x49, 0x7a, 0x26, 0xf6,
	0xc7, 0xd9, 0x99, 0xa3, 0x76, 0x31, 0x47, 0xed, 0xf6, 0x11, 0x54, 0xe4, 0x2d, 0x16, 0x47, 0x2b,
	0xe9, 0xa3, 0x5b, 0x50, 0xb4, 0xaf, 0xb0, 0xeb, 0xcb, 0x86, 0x84, 0x81, 0x9a, 0x50, 0x70, 0x9d,
	0xb8, 0x95, 0x82, 0xeb, 0xec, 0x1d, 0x42, 0x29, 0x7a, 0x9a, 0x08, 0x41, 0xb3, 0x73, 0x68, 0xea,
	0xaf, 0x86, 0x96, 0x3e, 0xbc, 0xe8, 0x9c, 0xea, 0x3d, 0x75, 0x09, 0xb5, 0x40, 0x8d, 0x7d, 0x46,
	0xbf, 0xd3, 0xb3, 0xce, 0xf5, 0xe3, 0xa1, 0xaa, 0xa0, 0x55, 0xa8, 0xa5, 0xbc, 0x6a, 0x61, 0x6f,
	0x0c, 0xcd, 0x2c, 0x71, 0xd0, 0x36, 0x68, 0x47, 0x7a, 0xff, 0xb4, 0x67, 0x0d, 0x3a, 0xe6, 0xe1,
	0x89, 0x65, 0xbe, 0x3d, 0xeb, 0xa7, 0xca, 0x6e, 0xc1, 0xfa, 0xad, 0xe8, 0x99, 0xd1, 0x3f, 0xd2,
	0xdf, 0xa8, 0x0a, 0xda, 0x84, 0xb5, 0x5b, 0xc1, 0xfe, 0x9b, 0xce, 0xa1, 0xa9, 0x16, 0xf6, 0x06,
	0xa0, 0xe6, 0x29, 0x85, 0x1e, 0xc2, 0x86, 0x69, 0x74, 0x86, 0xe7, 0xba, 0xe8, 0xe8, 0xd6, 0x15,
	0x36, 0x61, 0xed, 0x76, 0xb8, 0xdf, 0xd3, 0x4d, 0x55, 0xd9, 0xfb, 0x5b, 0x81, 0x46, 0xe6, 0xb1,
	0x73, 0x74, 0xc7, 0x34, 0x0d, 0xbd, 0xfb, 0xda, 0xec, 0xe7, 0xbb, 0xfe, 0x50, 0xcc, 0xec, 0x1f,
	0xf7, 0x8d, 0xa8, 0xe9, 0x5c, 0xac, 0xd7, 0x3f, 0xd4, 0x07, 0x9d, 0x53, 0xb5, 0x80, 0x36, 0xe0,
	0x41, 0x2e, 0x76, 0x6e, 0x1a, 0xfa, 0xf0, 0x58, 0x5d, 0x46, 0x1a, 0xb4, 0x72, 0xa1, 0xee, 0x5b,
	0xb3, 0x7f, 0xae, 0xae, 0xf0, 0x01, 0xe6, 0x22, 0xa6, 0x3e, 0xe8, 0x9f, 0x9b, 0x9d, 0xc1, 0x99,
	0x5a, 0xfc, 0x50, 0x49, 0xfd, 0x78, 0xd8, 0xef, 0xa9, 0x25, 0x3e, 0xdb, 0x5c, 0x68, 0xf0, 0x6a,
	0xd8, 0x37, 0x3b, 0xc6, 0x5b, 0xb5, 0xdc, 0x7d, 0x09, 0xaa, 0x1d, 0x4c, 0x32, 0x64, 0xe8, 0xde,
	0x3b, 0x4c, 0x59, 0x67, 0x9c, 0x93, 0x67, 0xca, 0xb7, 0xcd, 0x34, 0x64, 0x3a, 0x1a, 0x95, 0x04,
	0x59, 0x3f, 0xfb, 0x27, 0x00, 0x00, 0xff, 0xff, 0x54, 0xd3, 0x41, 0x4e, 0xd2, 0x0c, 0x00, 0x00,
}
