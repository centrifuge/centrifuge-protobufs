// Code generated by protoc-gen-go. DO NOT EDIT.
// source: coredocument/coredocument.proto

package coredocumentpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/centrifuge/precise-proofs/proofs/proto"
import any "github.com/golang/protobuf/ptypes/any"
import timestamp "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// `CoreDocument` is a document that can be sent to different nodes and anchored
// on chain. It handles all the generic features native Centrifuge Documents support:
//
// * Merkle Roots for the document data
// * Signatures on document data
// * Access Control
type CoreDocument struct {
	// # Identifiers
	// CoreDocument has two kinds of identifiers, the `document_identifier` is assigned
	// once per document and stays the same for the lifetime of the document.
	// document_identifier is the first ID ever used to anchor the document on chain and
	// is used internally to store all future versions. The `current_identifier` and the
	// `next_identifier` refer only to this particular version.
	//
	// 32 byte value
	DocumentIdentifier []byte `protobuf:"bytes,9,opt,name=document_identifier,json=documentIdentifier,proto3" json:"document_identifier,omitempty"`
	// current_identifier is the identifier used to refer to the current state of the document.
	//
	// 32 byte value
	CurrentIdentifier []byte `protobuf:"bytes,3,opt,name=current_identifier,json=currentIdentifier,proto3" json:"current_identifier,omitempty"`
	// next_identifier is the identifier that is going to be used for the next version if any
	// party wants to update the state.
	NextIdentifier []byte `protobuf:"bytes,4,opt,name=next_identifier,json=nextIdentifier,proto3" json:"next_identifier,omitempty"`
	// # Merkle roots
	// document_root the root of all roots. It's signature_root along with a list of all signatures
	DocumentRoot []byte `protobuf:"bytes,7,opt,name=document_root,json=documentRoot,proto3" json:"document_root,omitempty"`
	// signing_root is the Merkle root calculated from all fields on the document that need
	// to be signed. This is all fields except for the signatures themselves and the `document_root`.
	SigningRoot []byte `protobuf:"bytes,10,opt,name=signing_root,json=signingRoot,proto3" json:"signing_root,omitempty"`
	// previous_root is the `document_root` of the previous version of the document
	PreviousRoot []byte `protobuf:"bytes,2,opt,name=previous_root,json=previousRoot,proto3" json:"previous_root,omitempty"`
	// data_root is the Merkle root calculated for the `embedded_data` & `embedded_salts` document (such as an invoice).
	DataRoot []byte `protobuf:"bytes,5,opt,name=data_root,json=dataRoot,proto3" json:"data_root,omitempty"`
	// Signatures
	// Signatures of the signature_root by centrifuge identities. This array should be sorted by the Centrifuge ID.
	Signatures []*Signature `protobuf:"bytes,6,rep,name=signatures" json:"signatures,omitempty"`
	// Document a serialized document
	EmbeddedData      *any.Any `protobuf:"bytes,13,opt,name=embedded_data,json=embeddedData" json:"embedded_data,omitempty"`
	EmbeddedDataSalts *any.Any `protobuf:"bytes,14,opt,name=embedded_data_salts,json=embeddedDataSalts" json:"embedded_data_salts,omitempty"`
	// CoreDocumentSalts is inlined
	CoredocumentSalts    *CoreDocumentSalts `protobuf:"bytes,15,opt,name=coredocument_salts,json=coredocumentSalts" json:"coredocument_salts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *CoreDocument) Reset()         { *m = CoreDocument{} }
func (m *CoreDocument) String() string { return proto.CompactTextString(m) }
func (*CoreDocument) ProtoMessage()    {}
func (*CoreDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_coredocument_c4c36d32b85a9f56, []int{0}
}
func (m *CoreDocument) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CoreDocument.Unmarshal(m, b)
}
func (m *CoreDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CoreDocument.Marshal(b, m, deterministic)
}
func (dst *CoreDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoreDocument.Merge(dst, src)
}
func (m *CoreDocument) XXX_Size() int {
	return xxx_messageInfo_CoreDocument.Size(m)
}
func (m *CoreDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_CoreDocument.DiscardUnknown(m)
}

var xxx_messageInfo_CoreDocument proto.InternalMessageInfo

func (m *CoreDocument) GetDocumentIdentifier() []byte {
	if m != nil {
		return m.DocumentIdentifier
	}
	return nil
}

func (m *CoreDocument) GetCurrentIdentifier() []byte {
	if m != nil {
		return m.CurrentIdentifier
	}
	return nil
}

func (m *CoreDocument) GetNextIdentifier() []byte {
	if m != nil {
		return m.NextIdentifier
	}
	return nil
}

func (m *CoreDocument) GetDocumentRoot() []byte {
	if m != nil {
		return m.DocumentRoot
	}
	return nil
}

func (m *CoreDocument) GetSigningRoot() []byte {
	if m != nil {
		return m.SigningRoot
	}
	return nil
}

func (m *CoreDocument) GetPreviousRoot() []byte {
	if m != nil {
		return m.PreviousRoot
	}
	return nil
}

func (m *CoreDocument) GetDataRoot() []byte {
	if m != nil {
		return m.DataRoot
	}
	return nil
}

func (m *CoreDocument) GetSignatures() []*Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *CoreDocument) GetEmbeddedData() *any.Any {
	if m != nil {
		return m.EmbeddedData
	}
	return nil
}

func (m *CoreDocument) GetEmbeddedDataSalts() *any.Any {
	if m != nil {
		return m.EmbeddedDataSalts
	}
	return nil
}

func (m *CoreDocument) GetCoredocumentSalts() *CoreDocumentSalts {
	if m != nil {
		return m.CoredocumentSalts
	}
	return nil
}

type CoreDocumentSalts struct {
	DocumentIdentifier   []byte   `protobuf:"bytes,9,opt,name=document_identifier,json=documentIdentifier,proto3" json:"document_identifier,omitempty"`
	CurrentIdentifier    []byte   `protobuf:"bytes,3,opt,name=current_identifier,json=currentIdentifier,proto3" json:"current_identifier,omitempty"`
	NextIdentifier       []byte   `protobuf:"bytes,4,opt,name=next_identifier,json=nextIdentifier,proto3" json:"next_identifier,omitempty"`
	PreviousRoot         []byte   `protobuf:"bytes,2,opt,name=previous_root,json=previousRoot,proto3" json:"previous_root,omitempty"`
	DataRoot             []byte   `protobuf:"bytes,5,opt,name=data_root,json=dataRoot,proto3" json:"data_root,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CoreDocumentSalts) Reset()         { *m = CoreDocumentSalts{} }
func (m *CoreDocumentSalts) String() string { return proto.CompactTextString(m) }
func (*CoreDocumentSalts) ProtoMessage()    {}
func (*CoreDocumentSalts) Descriptor() ([]byte, []int) {
	return fileDescriptor_coredocument_c4c36d32b85a9f56, []int{1}
}
func (m *CoreDocumentSalts) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CoreDocumentSalts.Unmarshal(m, b)
}
func (m *CoreDocumentSalts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CoreDocumentSalts.Marshal(b, m, deterministic)
}
func (dst *CoreDocumentSalts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoreDocumentSalts.Merge(dst, src)
}
func (m *CoreDocumentSalts) XXX_Size() int {
	return xxx_messageInfo_CoreDocumentSalts.Size(m)
}
func (m *CoreDocumentSalts) XXX_DiscardUnknown() {
	xxx_messageInfo_CoreDocumentSalts.DiscardUnknown(m)
}

var xxx_messageInfo_CoreDocumentSalts proto.InternalMessageInfo

func (m *CoreDocumentSalts) GetDocumentIdentifier() []byte {
	if m != nil {
		return m.DocumentIdentifier
	}
	return nil
}

func (m *CoreDocumentSalts) GetCurrentIdentifier() []byte {
	if m != nil {
		return m.CurrentIdentifier
	}
	return nil
}

func (m *CoreDocumentSalts) GetNextIdentifier() []byte {
	if m != nil {
		return m.NextIdentifier
	}
	return nil
}

func (m *CoreDocumentSalts) GetPreviousRoot() []byte {
	if m != nil {
		return m.PreviousRoot
	}
	return nil
}

func (m *CoreDocumentSalts) GetDataRoot() []byte {
	if m != nil {
		return m.DataRoot
	}
	return nil
}

// Signature contains the entity ID, public key used and signature)
type Signature struct {
	// `entity_id` is the CentrifugeID of the entity signing the document.
	EntityId []byte `protobuf:"bytes,1,opt,name=entity_id,json=entityId,proto3" json:"entity_id,omitempty"`
	// `public_key` is the public key of the `entity` used for signing the `CoreDocument`
	PublicKey            []byte               `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	Signature            []byte               `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	Timestamp            *timestamp.Timestamp `protobuf:"bytes,4,opt,name=timestamp" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_coredocument_c4c36d32b85a9f56, []int{2}
}
func (m *Signature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Signature.Unmarshal(m, b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
}
func (dst *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(dst, src)
}
func (m *Signature) XXX_Size() int {
	return xxx_messageInfo_Signature.Size(m)
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetEntityId() []byte {
	if m != nil {
		return m.EntityId
	}
	return nil
}

func (m *Signature) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *Signature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Signature) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func init() {
	proto.RegisterType((*CoreDocument)(nil), "coredocument.CoreDocument")
	proto.RegisterType((*CoreDocumentSalts)(nil), "coredocument.CoreDocumentSalts")
	proto.RegisterType((*Signature)(nil), "coredocument.Signature")
}

func init() {
	proto.RegisterFile("coredocument/coredocument.proto", fileDescriptor_coredocument_c4c36d32b85a9f56)
}

var fileDescriptor_coredocument_c4c36d32b85a9f56 = []byte{
	// 495 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x93, 0xbf, 0x8e, 0xd3, 0x40,
	0x10, 0xc6, 0x65, 0xee, 0x0f, 0x78, 0xe2, 0xe4, 0xc8, 0x1e, 0x12, 0x26, 0x80, 0x12, 0x85, 0xe2,
	0xa2, 0x93, 0xce, 0x96, 0x42, 0x01, 0x15, 0x82, 0x70, 0xcd, 0xe9, 0x9a, 0x53, 0x0e, 0x1a, 0x1a,
	0xcb, 0x7f, 0x26, 0xd1, 0x8a, 0xd8, 0x6b, 0xad, 0xd7, 0x08, 0x3f, 0x0d, 0x94, 0xbc, 0x06, 0x2f,
	0x42, 0xc3, 0x33, 0xd0, 0x23, 0xef, 0x7a, 0x9d, 0x75, 0x82, 0x44, 0x7b, 0x55, 0xb4, 0xf3, 0xfd,
	0xe6, 0xf3, 0x8c, 0xe6, 0x0b, 0x8c, 0x63, 0xc6, 0x31, 0x61, 0x71, 0x99, 0x62, 0x26, 0x7c, 0xf3,
	0xe1, 0xe5, 0x9c, 0x09, 0x46, 0x1c, 0xb3, 0x36, 0x7a, 0xb2, 0x66, 0x6c, 0xbd, 0x41, 0x5f, 0x6a,
	0x51, 0xb9, 0xf2, 0xc3, 0xac, 0x52, 0xe0, 0x68, 0xbc, 0x2b, 0x09, 0x9a, 0x62, 0x21, 0xc2, 0x34,
	0x6f, 0x80, 0xb3, 0x9c, 0x63, 0x4c, 0x0b, 0xbc, 0xc8, 0x39, 0x63, 0xab, 0xc2, 0xdf, 0xfe, 0x08,
	0xa6, 0x1e, 0x0a, 0x9c, 0xfe, 0x3e, 0x04, 0xe7, 0x3d, 0xe3, 0x78, 0xd9, 0x7c, 0x95, 0xf8, 0x70,
	0xaa, 0x27, 0x08, 0x68, 0x82, 0x99, 0xa0, 0x2b, 0x8a, 0xdc, 0xb5, 0x27, 0xd6, 0xcc, 0x59, 0x12,
	0x2d, 0x5d, 0xb5, 0x0a, 0xb9, 0x00, 0x12, 0x97, 0x9c, 0xef, 0xf0, 0x07, 0x92, 0x1f, 0x36, 0x8a,
	0x81, 0x9f, 0xc1, 0x49, 0x86, 0x5f, 0x3b, 0xec, 0xa1, 0x64, 0x07, 0x75, 0xd9, 0x00, 0xcf, 0xa1,
	0xdf, 0x0e, 0xc2, 0x19, 0x13, 0xee, 0xfd, 0x1a, 0x5b, 0x1c, 0x7d, 0xff, 0xf9, 0x07, 0xac, 0xa5,
	0xa3, 0xb5, 0x25, 0x63, 0x82, 0xcc, 0xc0, 0x29, 0xe8, 0x3a, 0xa3, 0xd9, 0x5a, 0xa1, 0x60, 0xa2,
	0xbd, 0x46, 0x92, 0xe4, 0x39, 0xf4, 0x73, 0x8e, 0x5f, 0x28, 0x2b, 0x0b, 0x85, 0xde, 0x53, 0xe8,
	0x0f, 0xe5, 0xaa, 0x35, 0xc9, 0x4e, 0xc1, 0x4e, 0x42, 0x11, 0x2a, 0xee, 0xc8, 0xe4, 0x1e, 0xd4,
	0x75, 0xc9, 0xbc, 0x01, 0xa8, 0xed, 0x43, 0x51, 0x72, 0x2c, 0xdc, 0xe3, 0xc9, 0xc1, 0xac, 0x37,
	0x7f, 0xec, 0x75, 0x6e, 0x7b, 0xab, 0x75, 0x3d, 0x90, 0xd1, 0x41, 0xde, 0x42, 0x1f, 0xd3, 0x08,
	0x93, 0x04, 0x93, 0xa0, 0x36, 0x75, 0xfb, 0x13, 0x6b, 0xd6, 0x9b, 0x3f, 0xf2, 0xd4, 0x85, 0x3d,
	0x7d, 0x61, 0xef, 0x5d, 0x56, 0xb5, 0xbb, 0xeb, 0x8e, 0xcb, 0x50, 0x84, 0xe4, 0x1a, 0x4e, 0x3b,
	0x0e, 0x41, 0x11, 0x6e, 0x44, 0xe1, 0x0e, 0xfe, 0xef, 0x33, 0x34, 0x7d, 0x6e, 0xeb, 0x2e, 0xf2,
	0x11, 0x88, 0x39, 0x7b, 0xe3, 0x75, 0x22, 0xbd, 0xc6, 0xdd, 0xb5, 0xcc, 0xd4, 0xc8, 0xe6, 0xd6,
	0xd6, 0xc4, 0xa4, 0x32, 0xfd, 0x65, 0xc1, 0x70, 0x8f, 0xbf, 0x3b, 0x51, 0x7b, 0xf1, 0xcf, 0x50,
	0xec, 0xa4, 0xe1, 0xe9, 0x5e, 0x1a, 0xb6, 0x31, 0x98, 0x7e, 0xb3, 0xc0, 0x6e, 0xef, 0x5c, 0xa3,
	0xb5, 0xb7, 0xa8, 0x02, 0x9a, 0xb8, 0x96, 0x42, 0x55, 0xe1, 0x2a, 0x21, 0xcf, 0x01, 0xf2, 0x32,
	0xda, 0xd0, 0x38, 0xf8, 0x8c, 0x55, 0xf3, 0x25, 0x5b, 0x55, 0xae, 0xb1, 0x22, 0xcf, 0xc0, 0x6e,
	0xe3, 0xd1, 0xac, 0xb6, 0x2d, 0x90, 0xd7, 0x60, 0xb7, 0x7f, 0x75, 0xb9, 0x4c, 0x6f, 0x3e, 0xda,
	0x3b, 0xf1, 0x07, 0x4d, 0x2c, 0xb7, 0xf0, 0xe2, 0x15, 0x3c, 0x8c, 0x59, 0xda, 0x39, 0xe1, 0x42,
	0xde, 0x44, 0xbf, 0x6e, 0xea, 0xf6, 0x1b, 0xeb, 0xd3, 0xc0, 0x44, 0xf2, 0x28, 0x3a, 0x96, 0xbe,
	0x2f, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x24, 0x85, 0x09, 0xd6, 0xbe, 0x04, 0x00, 0x00,
}
